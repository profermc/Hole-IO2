// Performance: Cap object count to improve rendering performance
if (objects.length > 100) objects.splice(0, objects.length - 100);

// Enhance object creation with non-overlapping checks
function createObjects(count) {
    for (let i = 0; i < count; i++) {
        let x, y, radius, valid;
        do {
            radius = Math.random() * 20 + 10;
            x = Math.random() * (canvas.width / scale - 2 * radius) + radius;
            y = Math.random() * (canvas.height / scale - 2 * radius) + radius;
            valid = objects.every(obj => {
                const dx = obj.x - x;
                const dy = obj.y - y;
                return Math.sqrt(dx * dx + dy * dy) > obj.radius + radius;
            });
        } while (!valid);
        objects.push({ x, y, radius, color: `hsl(${Math.random() * 360}, 70%, 60%)` });
    }
}

// Dynamic growth to balance gameplay
function isColliding(hole, obj) {
    const dx = hole.x - obj.x;
    const dy = hole.y - obj.y;
    const distance = Math.sqrt(dx * dx + dy * dy);
    if (distance < hole.radius - obj.radius * 0.5) {
        const growthRate = Math.max(obj.radius * 0.05, 3);
        hole.radius += growthRate * (1 - hole.radius / maxHoleSize);
        return true;
    }
    return false;
}

// Moving objects for dynamic gameplay
function moveObjects() {
    objects.forEach(obj => {
        obj.x += Math.random() * 2 - 1;
        obj.y += Math.random() * 2 - 1;
        obj.x = clamp(obj.x, obj.radius, canvas.width / scale - obj.radius);
        obj.y = clamp(obj.y, obj.radius, canvas.height / scale - obj.radius);
    });
}

// Add time limit for win condition
const timeLimit = 120000; // 2 minutes
let startTime = Date.now();

function checkWin() {
    const timeElapsed = Date.now() - startTime;
    if (hole.radius >= maxHoleSize || timeElapsed >= timeLimit) {
        gameWon = true;
        showWinScreen();
    }
}

// Audio feedback for better immersion
const eatSound = new Audio("eat.mp3"); // Add a sound file named 'eat.mp3'
const winSound = new Audio("win.mp3"); // Add a sound file named 'win.mp3'

function playEatSound() {
    eatSound.play();
}

function playWinSound() {
    winSound.play();
}

// Visual absorption effect
function absorbEffect(obj) {
    ctx.beginPath();
    ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
    ctx.fill();
    ctx.closePath();
}

// Integrate enhancements into the game loop
function gameLoop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Draw the hole
    ctx.beginPath();
    ctx.arc(hole.x, hole.y, hole.radius, 0, Math.PI * 2);
    ctx.fillStyle = "black";
    ctx.fill();
    ctx.closePath();

    // Draw dots and check collisions
    for (let i = objects.length - 1; i >= 0; i--) {
        const obj = objects[i];
        ctx.beginPath();
        ctx.arc(obj.x, obj.y, obj.radius, 0, Math.PI * 2);
        ctx.fillStyle = obj.color;
        ctx.fill();
        ctx.closePath();

        if (isColliding(hole, obj)) {
            playEatSound();
            absorbEffect(obj);
            objects.splice(i, 1);
        }
    }

    // Move objects for dynamic gameplay
    moveObjects();

    // Allow the hole to extend slightly beyond the edges
    hole.x = clamp(hole.x, -hole.radius / 2, canvas.width / scale + hole.radius / 2);
    hole.y = clamp(hole.y, -hole.radius / 2, canvas.height / scale + hole.radius / 2);

    // Check for win condition
    checkWin();

    // Respawn dots if necessary
    if (objects.length < 5 && !gameWon) {
        createObjects(10);
    }

    requestAnimationFrame(gameLoop);
}
      
